<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Aim Lab - Shooting Range</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* UI Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
        }

        .hud-bar { margin-top: 20px; display: flex; align-items: center; justify-content: center; gap: 10px; }
        
        .hud-panel {
            background: rgba(30, 30, 60, 0.9); color: white; padding: 10px 30px;
            border-radius: 4px; font-weight: bold; font-size: 20px; min-width: 80px;
            text-align: center; border-bottom: 3px solid #4a4a8a;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .hud-center {
            background: rgba(40, 40, 70, 0.95); font-size: 28px; padding: 10px 40px;
            clip-path: polygon(10% 0, 90% 0, 100% 100%, 0% 100%);
            border-bottom: 3px solid #00d2ff; color: white; font-weight: bold;
        }

        .label { font-size: 12px; color: #aaa; display: block; margin-bottom: 2px; }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background-color: #00ff00;
            border-radius: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 4px #00ff00;
        }

        /* Menu Overlay */
        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 15, 25, 0.85);
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 100; backdrop-filter: blur(5px);
        }

        .menu-box {
            background: #1e1e2e; padding: 40px; border-radius: 8px;
            text-align: center; border: 1px solid #444; color: white; width: 450px;
        }

        h1 { margin: 0 0 20px 0; color: #00d2ff; text-transform: uppercase; letter-spacing: 2px; }
        
        .btn {
            background: #00d2ff; color: #1e1e2e;
            border: none; padding: 15px 30px; width: 100%;
            font-size: 18px; font-weight: bold; cursor: pointer; border-radius: 4px;
            transition: 0.2s; margin-top: 20px;
        }
        .btn:hover { background: white; }

        .setting-row {
            display: flex; justify-content: space-between; align-items: center;
            margin: 15px 0; color: #ccc; font-size: 16px;
        }
        
        input[type=range] { width: 45%; accent-color: #00d2ff; }
        select { width: 45%; padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }

        .hidden { display: none !important; }
        .result-text { font-size: 14px; color: #aaa; margin-top: 10px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-bar">
            <div class="hud-panel"><span class="label">SCORE</span><span id="score">0</span></div>
            <div class="hud-center"><span id="time">01:00</span></div>
            <div class="hud-panel"><span class="label">ACCURACY</span><span id="accuracy">100%</span></div>
        </div>
        <div id="crosshair"></div>
    </div>

    <div id="menu-overlay">
        <div class="menu-box">
            <h1>AIM TRAINER PRO</h1>
            
            <div id="result-area" class="hidden">
                <h2 style="color:white; margin-bottom:5px;">Result</h2>
                <div class="result-text">Score: <span id="final-score" style="color:#00d2ff; font-weight:bold">0</span></div>
                <div class="result-text">Accuracy: <span id="final-acc">0%</span></div>
                <hr style="border-color:#333; margin: 20px 0;">
            </div>
            
            <div class="setting-row">
                <span>Game Mode</span>
                <select id="mode-select">
                    <option value="grid">Gridshot (Balls)</option>
                    <option value="bot">Bot Range (Humanoids)</option>
                </select>
            </div>

            <div class="setting-row">
                <span>Difficulty (Size)</span>
                <select id="diff-select">
                    <!-- 크기를 전체적으로 키웠습니다 -->
                    <option value="2.2">Easy (Huge)</option>
                    <option value="1.6" selected>Normal</option>
                    <option value="1.2">Hard</option>
                    <option value="0.8">Expert</option>
                </select>
            </div>

            <div class="setting-row">
                <span>Sensitivity</span>
                <input type="range" id="sens-slider" min="0.1" max="5.0" step="0.1" value="1.0">
                <span id="sens-display">1.0</span>
            </div>

            <button class="btn" id="start-btn">CLICK TO START</button>
            <p style="font-size: 12px; color: #666; margin-top: 15px;">Press <b>ESC</b> for Menu</p>
        </div>
    </div>

    <script>
        // === 1. 오디오 ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const bufferSize = audioCtx.sampleRate * 2.0;
        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const t = audioCtx.currentTime;
            if (type === 'shoot') {
                const src = audioCtx.createBufferSource(); src.buffer = noiseBuffer;
                const gain = audioCtx.createGain(); const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass'; filter.frequency.setValueAtTime(1200, t); filter.frequency.exponentialRampToValueAtTime(100, t + 0.15);
                gain.gain.setValueAtTime(0.7, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                src.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); src.start(t); src.stop(t + 0.2);
                
                const osc = audioCtx.createOscillator(); const oscGain = audioCtx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(600, t); osc.frequency.linearRampToValueAtTime(100, t + 0.05);
                oscGain.gain.setValueAtTime(0.1, t); oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                osc.connect(oscGain); oscGain.connect(audioCtx.destination); osc.start(t); osc.stop(t+0.1);
            } else if (type === 'hit') {
                const src = audioCtx.createBufferSource(); src.buffer = noiseBuffer;
                const gain = audioCtx.createGain(); const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 3000; 
                gain.gain.setValueAtTime(0.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
                src.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination); src.start(t); src.stop(t + 0.1);
            }
        }

        // === 2. 전역 변수 ===
        let scene, camera, renderer;
        let gunGroup, gunSlide, gunRecoilRot = 0, slideRecoil = 0;
        let targets = [];
        let particles = [];
        
        let isPlaying = false;
        let score = 0;
        let timeLeft = 60;
        let totalShots = 0;
        let hitShots = 0;
        let timerInterval;
        
        // Settings
        let sensitivity = 1.0;
        let targetSize = 1.6; // 기본값 키움
        let gameMode = 'grid'; // 'grid' or 'bot'

        const TARGET_COUNT = 3;
        const WALL_DISTANCE = 40; 
        const SPAWN_X = 9;  
        const SPAWN_Y = 5;  
        
        // DOM
        const uiScore = document.getElementById('score');
        const uiTime = document.getElementById('time');
        const uiAcc = document.getElementById('accuracy');
        const menuOverlay = document.getElementById('menu-overlay');
        const startBtn = document.getElementById('start-btn');
        const sensSlider = document.getElementById('sens-slider');
        const sensDisplay = document.getElementById('sens-display');
        const diffSelect = document.getElementById('diff-select');
        const modeSelect = document.getElementById('mode-select');
        const resultArea = document.getElementById('result-area');
        const finalScoreEl = document.getElementById('final-score');
        const finalAccEl = document.getElementById('final-acc');

        // === 3. 초기화 ===
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.fog = new THREE.Fog(0x222222, 30, 80);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 150);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            createRoom(); 
            createDetailedGun(); 

            window.addEventListener('resize', onResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            
            sensSlider.addEventListener('input', (e) => {
                sensitivity = parseFloat(e.target.value);
                sensDisplay.innerText = sensitivity.toFixed(1);
            });
            diffSelect.addEventListener('change', (e) => {
                targetSize = parseFloat(e.target.value);
                if(!isPlaying && targets.length > 0) resetTargets();
            });
            modeSelect.addEventListener('change', (e) => {
                gameMode = e.target.value;
                if(!isPlaying) resetTargets();
            });
            startBtn.addEventListener('click', startGameRequest);

            animate();
        }

        function createGridTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#444444'; ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = '#333333'; ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, 512, 512);
            ctx.beginPath(); ctx.moveTo(256, 0); ctx.lineTo(256, 512); ctx.moveTo(0, 256); ctx.lineTo(512, 256); ctx.stroke();
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(20, 20);
            return texture;
        }

        function createRoom() {
            const gridTex = createGridTexture();
            const material = new THREE.MeshStandardMaterial({ map: gridTex, roughness: 0.8 });
            
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(150, 150), material);
            floor.rotation.x = -Math.PI / 2; floor.position.y = -10; floor.receiveShadow = true; scene.add(floor);
            const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(150, 80), material);
            frontWall.position.z = -WALL_DISTANCE; frontWall.receiveShadow = true; scene.add(frontWall);
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(150, 150), material);
            ceiling.rotation.x = Math.PI / 2; ceiling.position.y = 30; scene.add(ceiling);
            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(150, 80), material);
            leftWall.rotation.y = Math.PI / 2; leftWall.position.x = -40; scene.add(leftWall);
            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(150, 80), material);
            rightWall.rotation.y = -Math.PI / 2; rightWall.position.x = 40; scene.add(rightWall);
        }

        function createDetailedGun() {
            gunGroup = new THREE.Group();
            const metalBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3, metalness: 0.6 });
            const metalGrey = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.5 });
            const darkGrip = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.9 });

            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.28, 0.16), darkGrip);
            grip.rotation.x = 0.25; grip.position.set(0, -0.18, 0.15); gunGroup.add(grip);
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.06, 0.45), metalBlack);
            frame.position.set(0, -0.04, 0); gunGroup.add(frame);
            const guardBottom = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.01, 0.15), metalBlack);
            guardBottom.position.set(0, -0.15, -0.05); gunGroup.add(guardBottom);
            
            gunSlide = new THREE.Group();
            const slideMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.46), metalGrey);
            gunSlide.add(slideMesh);
            const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.02, 0.01), metalBlack);
            frontSight.position.set(0, 0.06, -0.22); gunSlide.add(frontSight);
            const rearSightL = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.02, 0.01), metalBlack);
            rearSightL.position.set(-0.03, 0.06, 0.22); gunSlide.add(rearSightL);
            const rearSightR = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.02, 0.01), metalBlack);
            rearSightR.position.set(0.03, 0.06, 0.22); gunSlide.add(rearSightR);
            gunSlide.position.set(0, 0.04, 0); gunGroup.add(gunSlide);

            gunGroup.scale.set(0.6, 0.6, 0.6); 
            gunGroup.position.set(0.25, -0.25, -0.5);
            camera.add(gunGroup); scene.add(camera);
        }

        // === 게임 로직 ===
        function startGameRequest() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            document.body.requestPointerLock();
        }

        function onPointerLockChange() {
            if (document.pointerLockElement === document.body) {
                menuOverlay.classList.add('hidden');
                isPlaying = true;
                if (timeLeft === 60 && totalShots === 0) resetGame();
            } else {
                menuOverlay.classList.remove('hidden');
                isPlaying = false;
                startBtn.innerText = "RESUME";
            }
        }

        function resetGame() {
            score = 0; timeLeft = 60; totalShots = 0; hitShots = 0;
            targetSize = parseFloat(diffSelect.value);
            gameMode = modeSelect.value;
            updateHUD();
            resetTargets();

            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(!isPlaying) return;
                timeLeft--;
                updateHUD();
                if(timeLeft <= 0) endGame();
            }, 1000);
        }

        function resetTargets() {
            targets.forEach(t => scene.remove(t));
            targets = [];
            for(let i=0; i<TARGET_COUNT; i++) spawnTarget();
        }

        function endGame() {
            isPlaying = false;
            clearInterval(timerInterval);
            document.exitPointerLock();
            resultArea.classList.remove('hidden');
            startBtn.innerText = "PLAY AGAIN";
            finalScoreEl.innerText = score.toLocaleString();
            let acc = totalShots === 0 ? 0 : Math.round((hitShots / totalShots) * 100);
            finalAccEl.innerText = acc + "%";
            timeLeft = 60; totalShots = 0;
        }

        // === 타겟 생성 로직 분기 ===
        function spawnTarget() {
            if (gameMode === 'bot') {
                spawnBotTarget();
            } else {
                spawnSphereTarget();
            }
        }

        // 1. Gridshot (공)
        function spawnSphereTarget() {
            const geometry = new THREE.SphereGeometry(targetSize, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: 0x00d2ff, emissive: 0x004455, shininess: 100 });
            const target = new THREE.Mesh(geometry, material);
            placeTargetWithoutOverlap(target, 'sphere');
            target.userData = { growing: true, isTarget: true, type: 'sphere' };
            scene.add(target);
            targets.push(target);
        }

        // 2. Bot Range (봇)
        function spawnBotTarget() {
            const botGroup = new THREE.Group();
            
            // 크기 스케일 (난이도에 따라)
            const scale = targetSize * 0.8; 

            // 몸통
            const bodyGeo = new THREE.BoxGeometry(1.2 * scale, 1.8 * scale, 0.6 * scale);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0x00d2ff, emissive: 0x002233 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0; // 중심
            botGroup.add(body);

            // 머리
            const headGeo = new THREE.SphereGeometry(0.5 * scale, 32, 32);
            const headMat = new THREE.MeshPhongMaterial({ color: 0xff5500, emissive: 0x442200 }); // 헤드샷 컬러
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.3 * scale; 
            botGroup.add(head);

            placeTargetWithoutOverlap(botGroup, 'bot');
            
            // 그룹 전체를 타겟으로 인식시키기 위해 userData 설정
            botGroup.userData = { growing: true, isTarget: true, type: 'bot' };
            // 자식들에게도 전파 (레이캐스팅 편의상)
            body.userData = { parentGroup: botGroup };
            head.userData = { parentGroup: botGroup };

            scene.add(botGroup);
            targets.push(botGroup);
        }

        // 겹침 방지 및 위치 지정 통합 함수
        function placeTargetWithoutOverlap(obj, type) {
            let valid = false;
            let attempts = 0;
            let px, py;
            
            // 봇은 공보다 좀 더 넓은 공간 필요
            const checkDist = (type === 'bot') ? targetSize * 3 : targetSize * 2.5;

            while (!valid && attempts < 50) {
                px = (Math.random() - 0.5) * SPAWN_X * 2;
                
                if (type === 'bot') {
                    // 봇은 바닥에 서있어야 함 (Y값 고정 혹은 약간의 높이차)
                    // 방 바닥이 -10이므로, 봇의 발이 -10에 닿도록
                    // 봇 중심이 0이므로 scale 고려해서 배치
                    // 여기서는 약간 공중에 띄워서 잘 보이게 함
                    py = -10 + (targetSize * 2); 
                } else {
                    // 공은 공중 부양
                    py = (Math.random() - 0.5) * SPAWN_Y * 2 + 5;
                }

                valid = true;
                for (const t of targets) {
                    const dx = px - t.position.x;
                    const dy = py - t.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < checkDist) {
                        valid = false;
                        break;
                    }
                }
                attempts++;
            }
            obj.position.set(px, py, -WALL_DISTANCE + 5);
            
            // 등장 애니메이션용 초기 스케일
            obj.scale.set(0.1, 0.1, 0.1);
        }

        function createExplosion(pos) {
            const particleCount = 8;
            const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00d2ff });
            for(let i=0; i<particleCount; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.userData = {
                    vel: new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5),
                        (Math.random() - 0.5) + 0.5
                    ), life: 1.0
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function onMouseMove(e) {
            if (!isPlaying) return;
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= e.movementX * 0.002 * sensitivity;
            euler.x -= e.movementY * 0.002 * sensitivity;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        }

        function onMouseDown(e) {
            if (!isPlaying || e.button !== 0) return;
            
            totalShots++;
            gunRecoilRot = 0.12; slideRecoil = 0.15;
            playSound('shoot'); 

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // 씬의 모든 오브젝트와 교차 검사 (그룹 내부 메시 포함)
            // targets 배열 안에 Group이 들어있을 수 있으므로 recursive하게 체크해야 함
            // 하지만 targets 배열만 넣으면 Group 자체랑은 raycast가 안될 수도 있어 scene.children을 쓰거나
            // targets 배열을 traverse 해야함. Three.js Raycaster는 그룹을 넣으면 자식까지 검사해줌.
            const intersects = raycaster.intersectObjects(targets, true);

            if (intersects.length > 0) {
                // 가장 가까운 물체
                const hitObj = intersects[0].object;
                let targetRoot = null;

                // 맞은게 그룹의 일부(봇)인지, 구체(공)인지 확인
                if (hitObj.userData.parentGroup) {
                    targetRoot = hitObj.userData.parentGroup;
                } else if (hitObj.userData.isTarget) {
                    targetRoot = hitObj;
                }

                if (targetRoot) {
                    hitShots++; score += 100;
                    playSound('hit'); 
                    createExplosion(intersects[0].point); // 맞은 부위에서 폭발
                    
                    scene.remove(targetRoot);
                    targets = targets.filter(t => t !== targetRoot);
                    spawnTarget();
                }
            }
            updateHUD();
        }

        function updateHUD() {
            uiScore.innerText = score.toLocaleString();
            let m = Math.floor(timeLeft / 60);
            let s = timeLeft % 60;
            uiTime.innerText = `0${m}:${s < 10 ? '0'+s : s}`;
            let acc = totalShots === 0 ? 100 : Math.round((hitShots / totalShots) * 100);
            uiAcc.innerText = acc + "%";
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isPlaying) {
                targets.forEach(t => {
                    if(t.userData.growing) {
                        t.scale.addScalar(0.15);
                        if(t.scale.x >= 1) { t.scale.set(1,1,1); t.userData.growing = false; }
                    }
                });
                if (gunRecoilRot > 0) {
                    gunGroup.rotation.x = gunRecoilRot * 1.5; gunGroup.position.z = -0.5 + (gunRecoilRot * 0.1); gunRecoilRot -= 0.015;
                } else { gunGroup.rotation.x = 0; gunGroup.position.z = -0.5; }
                if (slideRecoil > 0) { gunSlide.position.z = slideRecoil; slideRecoil -= 0.03; } else { gunSlide.position.z = 0; }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel); p.userData.life -= 0.03; p.scale.setScalar(p.userData.life * 0.2);
                if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>